# Code generated by bitproto. DO NOT EDIT.
 
import json
from dataclasses import dataclass, field
from typing import ClassVar, Dict, List, Union
from enum import IntEnum, unique
 
from bitprotolib import bp
 
 
@dataclass
class PackInformation(bp.MessageBase):
    # Number of bytes to serialize class PackInformation
    BYTES_LENGTH: ClassVar[int] = 8
 
    pack_voltage: int = 0 # 16bit
    pack_current: int = 0 # 16bit
    pack_soc: int = 0 # 8bit
    internal_communications_fault: bool = False # 1bit
    internal_conversion_fault: bool = False # 1bit
    weak_cell_fault: bool = False # 1bit
    low_cell_voltage_fault: bool = False # 1bit
    open_wiring_fault: bool = False # 1bit
    current_sensor_fault: bool = False # 1bit
    pack_voltage_sensor_fault: bool = False # 1bit
    weak_pack_fault: bool = False # 1bit
    voltage_redundancy_fault: bool = False # 1bit
    fan_monitor_fault: bool = False # 1bit
    thermistor_fault: bool = False # 1bit
    CANBUS_communications_fault: bool = False # 1bit
    always_on_supply_fault: bool = False # 1bit
    high_voltage_isolation_fault: bool = False # 1bit
    power_supply_12v_fault: bool = False # 1bit
    charge_limit_enforcement_fault: bool = False # 1bit
    discharge_limit_enforcement_fault: bool = False # 1bit
    charger_safety_relay_fault: bool = False # 1bit
    internal_memory_fault: bool = False # 1bit
    internal_thermistor_fault: bool = False # 1bit
    internal_logic_fault: bool = False # 1bit
    discharge_relay: bool = False # 1bit
    charge_relay: bool = False # 1bit
 
    def __post_init__(self):
        pass
 
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
 
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
            bp.MessageFieldProcessor(3, bp.Uint(8)),
            bp.MessageFieldProcessor(4, bp.Bool()),
            bp.MessageFieldProcessor(5, bp.Bool()),
            bp.MessageFieldProcessor(6, bp.Bool()),
            bp.MessageFieldProcessor(7, bp.Bool()),
            bp.MessageFieldProcessor(8, bp.Bool()),
            bp.MessageFieldProcessor(9, bp.Bool()),
            bp.MessageFieldProcessor(10, bp.Bool()),
            bp.MessageFieldProcessor(11, bp.Bool()),
            bp.MessageFieldProcessor(12, bp.Bool()),
            bp.MessageFieldProcessor(13, bp.Bool()),
            bp.MessageFieldProcessor(14, bp.Bool()),
            bp.MessageFieldProcessor(15, bp.Bool()),
            bp.MessageFieldProcessor(16, bp.Bool()),
            bp.MessageFieldProcessor(17, bp.Bool()),
            bp.MessageFieldProcessor(18, bp.Bool()),
            bp.MessageFieldProcessor(19, bp.Bool()),
            bp.MessageFieldProcessor(20, bp.Bool()),
            bp.MessageFieldProcessor(21, bp.Bool()),
            bp.MessageFieldProcessor(22, bp.Bool()),
            bp.MessageFieldProcessor(23, bp.Bool()),
            bp.MessageFieldProcessor(24, bp.Bool()),
            bp.MessageFieldProcessor(25, bp.Bool()),
            bp.MessageFieldProcessor(26, bp.Bool()),
        ]
        return bp.MessageProcessor(False, 63, field_processors)
 
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.pack_voltage |= (int(b) << lshift)
        if di.field_number == 2:
            self.pack_current |= (int(b) << lshift)
        if di.field_number == 3:
            self.pack_soc |= (int(b) << lshift)
        if di.field_number == 4:
            self.internal_communications_fault = bool(b)
        if di.field_number == 5:
            self.internal_conversion_fault = bool(b)
        if di.field_number == 6:
            self.weak_cell_fault = bool(b)
        if di.field_number == 7:
            self.low_cell_voltage_fault = bool(b)
        if di.field_number == 8:
            self.open_wiring_fault = bool(b)
        if di.field_number == 9:
            self.current_sensor_fault = bool(b)
        if di.field_number == 10:
            self.pack_voltage_sensor_fault = bool(b)
        if di.field_number == 11:
            self.weak_pack_fault = bool(b)
        if di.field_number == 12:
            self.voltage_redundancy_fault = bool(b)
        if di.field_number == 13:
            self.fan_monitor_fault = bool(b)
        if di.field_number == 14:
            self.thermistor_fault = bool(b)
        if di.field_number == 15:
            self.CANBUS_communications_fault = bool(b)
        if di.field_number == 16:
            self.always_on_supply_fault = bool(b)
        if di.field_number == 17:
            self.high_voltage_isolation_fault = bool(b)
        if di.field_number == 18:
            self.power_supply_12v_fault = bool(b)
        if di.field_number == 19:
            self.charge_limit_enforcement_fault = bool(b)
        if di.field_number == 20:
            self.discharge_limit_enforcement_fault = bool(b)
        if di.field_number == 21:
            self.charger_safety_relay_fault = bool(b)
        if di.field_number == 22:
            self.internal_memory_fault = bool(b)
        if di.field_number == 23:
            self.internal_thermistor_fault = bool(b)
        if di.field_number == 24:
            self.internal_logic_fault = bool(b)
        if di.field_number == 25:
            self.discharge_relay = bool(b)
        if di.field_number == 26:
            self.charge_relay = bool(b)
        return
 
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.pack_voltage >> rshift) & 255
        if di.field_number == 2:
            return (self.pack_current >> rshift) & 255
        if di.field_number == 3:
            return (self.pack_soc >> rshift) & 255
        if di.field_number == 4:
            return (int(self.internal_communications_fault) >> rshift) & 255
        if di.field_number == 5:
            return (int(self.internal_conversion_fault) >> rshift) & 255
        if di.field_number == 6:
            return (int(self.weak_cell_fault) >> rshift) & 255
        if di.field_number == 7:
            return (int(self.low_cell_voltage_fault) >> rshift) & 255
        if di.field_number == 8:
            return (int(self.open_wiring_fault) >> rshift) & 255
        if di.field_number == 9:
            return (int(self.current_sensor_fault) >> rshift) & 255
        if di.field_number == 10:
            return (int(self.pack_voltage_sensor_fault) >> rshift) & 255
        if di.field_number == 11:
            return (int(self.weak_pack_fault) >> rshift) & 255
        if di.field_number == 12:
            return (int(self.voltage_redundancy_fault) >> rshift) & 255
        if di.field_number == 13:
            return (int(self.fan_monitor_fault) >> rshift) & 255
        if di.field_number == 14:
            return (int(self.thermistor_fault) >> rshift) & 255
        if di.field_number == 15:
            return (int(self.CANBUS_communications_fault) >> rshift) & 255
        if di.field_number == 16:
            return (int(self.always_on_supply_fault) >> rshift) & 255
        if di.field_number == 17:
            return (int(self.high_voltage_isolation_fault) >> rshift) & 255
        if di.field_number == 18:
            return (int(self.power_supply_12v_fault) >> rshift) & 255
        if di.field_number == 19:
            return (int(self.charge_limit_enforcement_fault) >> rshift) & 255
        if di.field_number == 20:
            return (int(self.discharge_limit_enforcement_fault) >> rshift) & 255
        if di.field_number == 21:
            return (int(self.charger_safety_relay_fault) >> rshift) & 255
        if di.field_number == 22:
            return (int(self.internal_memory_fault) >> rshift) & 255
        if di.field_number == 23:
            return (int(self.internal_thermistor_fault) >> rshift) & 255
        if di.field_number == 24:
            return (int(self.internal_logic_fault) >> rshift) & 255
        if di.field_number == 25:
            return (int(self.discharge_relay) >> rshift) & 255
        if di.field_number == 26:
            return (int(self.charge_relay) >> rshift) & 255
        return bp.byte(0)  # Won't reached
 
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
 
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
 
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
 
 
@dataclass
class CellVoltage(bp.MessageBase):
    # Number of bytes to serialize class CellVoltage
    BYTES_LENGTH: ClassVar[int] = 6
 
    low_cell_voltage: int = 0 # 16bit
    low_cell_voltage_id: int = 0 # 8bit
    high_cell_voltage: int = 0 # 16bit
    high_cell_voltage_id: int = 0 # 8bit
 
    def __post_init__(self):
        pass
 
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
 
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
            bp.MessageFieldProcessor(2, bp.Uint(8)),
            bp.MessageFieldProcessor(3, bp.Uint(16)),
            bp.MessageFieldProcessor(4, bp.Uint(8)),
        ]
        return bp.MessageProcessor(False, 48, field_processors)
 
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.low_cell_voltage |= (int(b) << lshift)
        if di.field_number == 2:
            self.low_cell_voltage_id |= (int(b) << lshift)
        if di.field_number == 3:
            self.high_cell_voltage |= (int(b) << lshift)
        if di.field_number == 4:
            self.high_cell_voltage_id |= (int(b) << lshift)
        return
 
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.low_cell_voltage >> rshift) & 255
        if di.field_number == 2:
            return (self.low_cell_voltage_id >> rshift) & 255
        if di.field_number == 3:
            return (self.high_cell_voltage >> rshift) & 255
        if di.field_number == 4:
            return (self.high_cell_voltage_id >> rshift) & 255
        return bp.byte(0)  # Won't reached
 
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
 
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
 
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
 
 
@dataclass
class CellTemperature(bp.MessageBase):
    # Number of bytes to serialize class CellTemperature
    BYTES_LENGTH: ClassVar[int] = 4
 
    low_temperature: int = 0 # 8bit
    low_thermistor_id: int = 0 # 8bit
    high_temperature: int = 0 # 8bit
    high_thermistor_id: int = 0 # 8bit
 
    def __post_init__(self):
        pass
 
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
 
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(8)),
            bp.MessageFieldProcessor(2, bp.Uint(8)),
            bp.MessageFieldProcessor(3, bp.Uint(8)),
            bp.MessageFieldProcessor(4, bp.Uint(8)),
        ]
        return bp.MessageProcessor(False, 32, field_processors)
 
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.low_temperature |= (int(b) << lshift)
        if di.field_number == 2:
            self.low_thermistor_id |= (int(b) << lshift)
        if di.field_number == 3:
            self.high_temperature |= (int(b) << lshift)
        if di.field_number == 4:
            self.high_thermistor_id |= (int(b) << lshift)
        return
 
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.low_temperature >> rshift) & 255
        if di.field_number == 2:
            return (self.low_thermistor_id >> rshift) & 255
        if di.field_number == 3:
            return (self.high_temperature >> rshift) & 255
        if di.field_number == 4:
            return (self.high_thermistor_id >> rshift) & 255
        return bp.byte(0)  # Won't reached
 
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
 
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
 
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)


@dataclass
class SolarCurrent(bp.MessageBase):
    # Number of bytes to serialize class SolarCurrent
    BYTES_LENGTH: ClassVar[int] = 2
    total_current: int = 0 # 16bit
    def __post_init__(self):
        pass
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
        ]
        return bp.MessageProcessor(False, 16, field_processors)
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.total_current |= (int(b) << lshift)
        return
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.total_current >> rshift) & 255
        return bp.byte(0)  # Won't reached
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
@dataclass
class SolarVoltage(bp.MessageBase):
    # Number of bytes to serialize class SolarVoltage
    BYTES_LENGTH: ClassVar[int] = 8
    panel1_voltage: int = 0 # 16bit
    panel2_voltage: int = 0 # 16bit
    panel3_voltage: int = 0 # 16bit
    panel4_voltage: int = 0 # 16bit
    def __post_init__(self):
        pass
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
            bp.MessageFieldProcessor(3, bp.Uint(16)),
            bp.MessageFieldProcessor(4, bp.Uint(16)),
        ]
        return bp.MessageProcessor(False, 64, field_processors)
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.panel1_voltage |= (int(b) << lshift)
        if di.field_number == 2:
            self.panel2_voltage |= (int(b) << lshift)
        if di.field_number == 3:
            self.panel3_voltage |= (int(b) << lshift)
        if di.field_number == 4:
            self.panel4_voltage |= (int(b) << lshift)
        return
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.panel1_voltage >> rshift) & 255
        if di.field_number == 2:
            return (self.panel2_voltage >> rshift) & 255
        if di.field_number == 3:
            return (self.panel3_voltage >> rshift) & 255
        if di.field_number == 4:
            return (self.panel4_voltage >> rshift) & 255
        return bp.byte(0)  # Won't reached
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
@dataclass
class SolarTemp(bp.MessageBase):
    # Number of bytes to serialize class SolarTemp
    BYTES_LENGTH: ClassVar[int] = 8
    panel1_temp: int = 0 # 16bit
    panel2_temp: int = 0 # 16bit
    panel3_temp: int = 0 # 16bit
    panel4_temp: int = 0 # 16bit
    def __post_init__(self):
        pass
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
            bp.MessageFieldProcessor(3, bp.Uint(16)),
            bp.MessageFieldProcessor(4, bp.Uint(16)),
        ]
        return bp.MessageProcessor(False, 64, field_processors)
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.panel1_temp |= (int(b) << lshift)
        if di.field_number == 2:
            self.panel2_temp |= (int(b) << lshift)
        if di.field_number == 3:
            self.panel3_temp |= (int(b) << lshift)
        if di.field_number == 4:
            self.panel4_temp |= (int(b) << lshift)
        return
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.panel1_temp >> rshift) & 255
        if di.field_number == 2:
            return (self.panel2_temp >> rshift) & 255
        if di.field_number == 3:
            return (self.panel3_temp >> rshift) & 255
        if di.field_number == 4:
            return (self.panel4_temp >> rshift) & 255
        return bp.byte(0)  # Won't reached
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
@dataclass
class SolarPhoto(bp.MessageBase):
    # Number of bytes to serialize class SolarPhoto
    BYTES_LENGTH: ClassVar[int] = 8
    panel1_photo: int = 0 # 16bit
    panel2_photo: int = 0 # 16bit
    panel3_photo: int = 0 # 16bit
    panel4_photo: int = 0 # 16bit
    def __post_init__(self):
        pass
    @staticmethod
    def dict_factory(kv_pairs):
        return {k: v for k, v in kv_pairs if not k.startswith('_enum_field_proxy__')}
    def bp_processor(self) -> bp.Processor:
        field_processors: List[bp.Processor] = [
            bp.MessageFieldProcessor(1, bp.Uint(16)),
            bp.MessageFieldProcessor(2, bp.Uint(16)),
            bp.MessageFieldProcessor(3, bp.Uint(16)),
            bp.MessageFieldProcessor(4, bp.Uint(16)),
        ]
        return bp.MessageProcessor(False, 64, field_processors)
    def bp_set_byte(self, di: bp.DataIndexer, lshift: int, b: bp.byte) -> None:
        if di.field_number == 1:
            self.panel1_photo |= (int(b) << lshift)
        if di.field_number == 2:
            self.panel2_photo |= (int(b) << lshift)
        if di.field_number == 3:
            self.panel3_photo |= (int(b) << lshift)
        if di.field_number == 4:
            self.panel4_photo |= (int(b) << lshift)
        return
    def bp_get_byte(self, di: bp.DataIndexer, rshift: int) -> bp.byte:
        if di.field_number == 1:
            return (self.panel1_photo >> rshift) & 255
        if di.field_number == 2:
            return (self.panel2_photo >> rshift) & 255
        if di.field_number == 3:
            return (self.panel3_photo >> rshift) & 255
        if di.field_number == 4:
            return (self.panel4_photo >> rshift) & 255
        return bp.byte(0)  # Won't reached
    def bp_get_accessor(self, di: bp.DataIndexer) -> bp.Accessor:
        return bp.NilAccessor() # Won't reached
    def encode(self) -> bytearray:
        """
        Encode this object to bytearray.
        """
        s = bytearray(self.BYTES_LENGTH)
        ctx = bp.ProcessContext(True, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)
        return ctx.s
    def decode(self, s: bytearray) -> None:
        """
        Decode given bytearray s to this object.
        :param s: A bytearray with length at least `BYTES_LENGTH`.
        """
        assert len(s) >= self.BYTES_LENGTH, bp.NotEnoughBytes()
        ctx = bp.ProcessContext(False, s)
        self.bp_processor().process(ctx, bp.NIL_DATA_INDEXER, self)